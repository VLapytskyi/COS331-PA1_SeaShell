/*
 * Sea Shell - a simple Linux shell (command interpreter) written in C.
 * Version 1.0 (March 21, 2019)
 * Copyright (C) 2019 Volodymyr Lapytskyi
 * 
 * Developed as the Programming Assignment 1 for the COS 331a "Operating Systems" course at
 * the American University in Bulgaria
 * Submitted to Professor Anton Stoilov on March 21, 2019
 * 
 * If you have any questions about details of implementation, or discovered bugs, or licensing, or anything else - 
 * please contact me at VNL170@aubg.edu
 */

#include <unistd.h> // All the system calls
#include <stdlib.h> // Useful functions like exit() etc.
#include <stdio.h>  // All the I/O
#include <errno.h>  // Defines the errno variable which we need for the error detection
#include <string.h> // Functions for manipulating C-style strings
#include <fcntl.h>  // Needed for named semaphores
#include <sys/stat.h>   // Needed for named semaphores
#include <sys/types.h>  // Types like pid_t, size_t, sem_t etc.
#include <sys/wait.h>   // waitpid() function
#include <signal.h> // Functions for manipulating signals
#include <semaphore.h>  // Functions for manipulating semaphores

sem_t* mainBusy;    // We will use this semaphore in order to postpone the execution of the execv() call by the child process
                    // until the parent does all the preliminary tasks, like updating process' PID in the job table and outputting a diagnostic message

typedef enum processStatus {    // Enum type for a process' execution status
    running, stopped, done, terminated
} processStatus;

// processRecord - a struct type to be used for job records in the job table
// The job table is to be implemented as a doubly linked list - for this reason, we have 'prev' and 'next' pointers
typedef struct processRecord {
    char* command;  // Path to the executable
    pid_t pid;
    int exitCode;   // Last exit code returned by the process
    processStatus status;   // Current execution status, according to the enum defined above
    int background; // background flag; non-zero if the process is in the background

    struct processRecord* prev;
    struct processRecord* next;
} processRecord;

processRecord* procs = NULL;    // Pointer to the first record (the head) of the job table
                                // The head's 'prev' pointer will point to the tail (the last record); however, the tail's 'next' pointer will be NULL
processRecord* currentProc = NULL;  // This is the pointer to the record of the process that is currently in the foreground.
                                    // Respectively, if there's no process in the foreground, this is NULL
unsigned int nextJobNum = 1;    // size(job table) + 1

// statusUpdateItem - a struct type for the status updates generated by the updateStatus() function.
// Whenever the updateStatus() function discovers that a process terminated/stopped, it generates a
// struct of this type and places it into the status updates buffer (which is to be implemented as a queue modelled on the linked list)
// flushStatusBuffer() function flushes the status updates buffer and prints respective diagnostic status updates messages based on the contents of the buffer.
typedef struct statusUpdateItem {
    processRecord* proc;    // the record of the respective process
    int exitCode;   // the exit code at the moment of generating the update
    processStatus s;    // execution status at the moment of generating the update
    int backgr; // background flag at the moment of generating the update
    unsigned int jobNum;    // job number - used for printing messages; stored here to avoid calculating it several times for the same reason

    struct statusUpdateItem* next;  // next item in the linked list
} statusUpdateItem;

statusUpdateItem* statusBuffer = NULL;  // First item in the status updates buffer/queue (head)
statusUpdateItem* statusBufferTail = NULL;  // Last item in the status updates buffer/queue (tail)

// printAbout() - prints general information about the program; called at the startup
void printAbout() {
    printf("\nSea Shell v1.0\nCopyright (C) 2019 Volodymyr Lapytskyi\n");
    printf("Developed as the Programming Assignment 1 for the\nCOS 331 \"Operating Systems\" course at AUBG\n");
    printf("Submitted to Professor Anton Stoilov on March 21, 2019\n\n");
    printf("Type \"help\" for the help message.\n\n");

    return;
}

// printHelp() - prints the help message; called every time the user types 'help'
void printHelp() {
    printAbout();

    printf("The command prompt displays the current working directory.\n\n");

    printf("In order to execute a command, just type it, followed by a space and the relevant arguments,\n%s",
        "also separated with spaces, in the command line, just as you would do with any other command interpreter.\n\n");

    printf("Built-in commands:\n");

    printf("%-5s    %s\n", "bg", "Resume a job in the background;");
    printf("%-5s    %s\n", "", "supply the job number in the first argument.");
    printf("%-5s    %s\n", "", "See also the \"Job Control\" section of this help message.\n");

    printf("%-5s    %s\n", "cd", "Change working directory; the path to the new working");
    printf("%-5s    %s\n", "", "directory should be supplied as the first argument.\n");

    printf("%-5s    %s\n", "exit", "Exit the shell. Instead, you can press Ctrl-D.\n");

    printf("%-5s    %5s\n", "fg", "Resume a job in/bring a job to the foreground;");
    printf("%-5s    %s\n", "", "supply the job number in the first argument.");
    printf("%-5s    %s\n", "", "See also the \"Job Control\" section of this help message.\n");

    printf("%-5s    %s\n", "help", "Display this help message.\n");

    printf("%-5s    %s\n", "jobs", "Display all the jobs currently controlled by this instance of Sea Shell.");
    printf("%-5s    %s\n", "", "See also the \"Job Control\" section of this help message.\n");

    printf("All other commands are treated as external, thus the name of the command\n%s",
        "is to be treated as the path to an executable.\n\n");

    printf("If an external command contains the '/' character, the command will be seen as\n%s%s%s%s",
        "an explicit absolute/relative path to the executable, so the file will be searched for\n",
        "in the respective location relative to the current working directory.\n",
        "If the command does NOT include a forward slash, the respective file will be searched for\n",
        "in all directories specified in the PATH environment variable.\n\n");

    printf("If a command/an argument, or a part of one, is enclosed in double quotes (\"),\n%s%s%s",
        "any whitespaces contained in it will NOT be considered as the delimiters\n",
        "(i.e. an argument with a space will not be considered as two arguments). In such case,\n",
        "the double quotes will be removed from the argument when it is passed to the command.\n\n");
    printf("Also, any character in your command line can be escaped with the '\\' character,\n%s%s%s%s",
        "so that it will be treated \"as is\" (e.g. an escaped whitespace will be included\n",
        "in the parameter, without being counted as the delimiter; escaped double quotes\n",
        "will also appear in the parameter and will not be seen as double quotes).\n",
        "'\\' character can be escaped itself (i.e. '\\\\' results in '\\').\n\n");
    
    printf("Examples:\n\n");

    printf("%-20s    %s\n", "mkdir foo bar", "2 folders created: foo and bar;");
    printf("%-20s    %s\n", "mkdir \"foo bar\"", "folder 'foo bar' created;");
    printf("%-20s    %s\n", "mkdir fo\"o b\"ar", "folder 'foo bar' created;");
    printf("%-20s    %s\n", "mkdir foo\\ bar", "folder 'foo bar' created;");
    printf("%-20s    %s\n", "mkdir foo\\\\ bar", "2 folders created: foo\\ and bar;");
    printf("%-20s    %s\n", "mkdir \"\\foo\\ b\\ar\"", "folder 'foo bar' created;");
    printf("%-20s    %s\n", "mkdir fo\\\"o b\\\"ar", "2 folders created: fo\"o and b\"ar.");

    printf("\n\n    ==== Job Control ====\n\n");

    printf("Sea Shell v1.0 can keep track of several jobs simultaneously, each of\n%s%s",
        "them being either stopped (suspended), running in the background or running in\n",
        "the foreground (obviously, there can be no more than 1 job in the foreground).\n\n");

    printf("The following actions are available:\n\n");

    printf("%-42s    %s\n", "Display the list of all", "");
    printf("%-42s    %s\n", "    suspended & background jobs", "Type \"jobs\"\n");
    printf("%-42s    %s\n", "Run a command in the background", "Append the command line");
    printf("%-42s    %s\n", "", "    with the '&' sign\n");
    printf("%-42s    %s\n", "Terminate current foreground process", "");
    printf("%-42s    %s\n", "    and return to the shell", "Press Ctrl-C\n");
    printf("%-42s    %s\n", "Suspend current foreground process", "");
    printf("%-42s    %s\n", "    and return to the shell", "Press Ctrl-Z\n");
    printf("%-42s    %s\n", "Continue a suspended job in the background", "Type \"bg job_number\"\n");
    printf("%-42s    %s\n", "Continue a suspended job in the foreground", "Type \"fg job_number\"\n");
    printf("%-42s    %s\n", "Bring a background job to the foreground", "Type \"fg job_number\"\n");

    printf("\nEvery time before the shell prints the command prompt, it will notify you if\n%s%s",
        "the execution status of any job has changed since the previous prompt was displayed.\n",
        "After every such update, all the jobs that have been marked as 'Done' are forgotten.\n\n");

    printf("Both the \"jobs\" command and the real-time status updates share the same\n%s",
        "format of the process record information:\n\n");

    printf("1) [job_number]\n%s%s%s%s%s",
        "2) PID=process_ID\n",
        "3) execution_status\n",
        "4) If process is not running: (status last_exit_code)\n",
        "5) Path to the executable\n",
        "6) If the process is in background: &\n");

    printf("\n\n    ==== Author Information ====\n\n");
    printf("I am Volodymyr Lapytskyi, a sophomore student at the\n%s%s%s",
        "American University in Bulgaria, majoring in\n",
        "Computer Science and Economics.\n",
        "Email: VNL170@aubg.edu\n\n");

    printf("The source code for this program can be found on GitHub at\nhttps://github.com/vlapytskyi-aubg/COS331-PA1_SeaShell\n\n");

    return;
}

/* _printProcInfo() - outputs the formatted information about a process; mostly, called by the flushStatusBuffer() function and the 'jobs' internal command
 * Arguments:
 * p - the record of the respective process;
 * jobNum - job number;
 * backgr - background flag;
 * s - execution status;
 * exitCode - exit code.
 * 
 * Outputs the supplied information in the following format (described in the help message):
 * 1) [job_number]
 * 2) PID=process_ID
 * 3) execution_status
 * 4) If process is not running: (status last_execution_status)
 * 5) Path to the executable
 * 6) If the process is in background: &
 */
void _printProcInfo(processRecord* p, unsigned int jobNum, int backgr, processStatus s, int exitCode) {
    // First, convert the processStatus enum into string...
    char status[] = "Terminated";

    if (s == running) strcpy(status, "Running");
    else if (s == stopped) strcpy(status, "Stopped");
    else if (s == done) strcpy(status, "Done");

    // Now, output the info
    printf("[%d] PID=%d\t%s", jobNum, p->pid, status);
    if (s != running) printf(" (status %d)", exitCode);
    printf("\t%s", p->command);
    if (backgr) printf(" &");
    printf("\n");
}

/* flushStatusBuffer() - obtains all the records from the status updates buffer and prints respective diagnostic messages based on them.
 * Then, cleans all the resources for processes that have been marked as 'terminated' or 'done', and removes those processes from the job table.
 * Finally, empties the status updates buffer.
 */
void flushStatusBuffer() {
    statusUpdateItem* prev; // auxiliary variable

    statusBufferTail = NULL;    // the tail is needed only for adding new items to the buffer, so we don't need it already

    while (statusBuffer != NULL) {  // until the buffer is completely empty
        // First, print the process info...
        _printProcInfo(statusBuffer->proc, statusBuffer->jobNum, statusBuffer->backgr, statusBuffer->s, statusBuffer->exitCode);
        // Then, if the job is terminated/done...
        if (statusBuffer->proc->status == done || statusBuffer->proc->status == terminated) {
            // a) Connect the neighbors of the processed job between each other, so that they don't remember the processed job.
            //    i.e., we remove the process record from the job table.
            if (statusBuffer->proc->next != NULL) { // If the item is not the last in the queue...
                statusBuffer->proc->next->prev = statusBuffer->proc->prev;  // ...update the 'prev' pointer of the next item...
            } else procs->prev = statusBuffer->proc->prev;  // ...otherwise, update the 'prev' pointer of the head
            if (statusBuffer->proc == procs) {  // If the current item is being pointed to by the head, we need to update the head
                procs = procs->next;
            } else statusBuffer->proc->prev->next = statusBuffer->proc->next;   // If it is not in the head, update the 'next' pointer of the previous item
                                                                                // (if it is in the head, the 'next' pointer of the item pointed to by 'prev'
                                                                                // should always stay NULL, since it is the last item)

            // b) We unlink the named semaphore that was used at the time of creating the process
            char* semname = (char*) malloc(33); // Name of the semaphore. It should be of the form '/seashell10_childPID'
            if (!semname) {
                fprintf(stderr, "FATAL ERROR (MEMORY): Allocation failed. Terminating...\n");
                exit(2);
            }
            if (sprintf(semname, "/seashell10_%d", statusBuffer->proc->pid) < 0) {
                fprintf(stderr, "FATAL ERROR (UNKNOWN): Unable to create the name for the semaphore while deleting a process. Terminating...\n");
                exit(3);
            }

            if (sem_unlink(semname) != 0) {
                fprintf(stderr, "\nFATAL ERROR (UNKNOWN): unable to unlink the semaphore. Terminating...\n");
                exit(3);
            }

            // c) We free all the resources used for maintaining the process, and finally delete the record and decrease the job table size
            free(semname);
            free(statusBuffer->proc->command);
            free(statusBuffer->proc);
            nextJobNum--;
        }

        // Finally, we get rid of the current status update item, and move on to process the next one
        prev = statusBuffer;
        statusBuffer = statusBuffer->next;
        free(prev);
    }
}

/* pushStatusBuffer() - creates a new struct of the type statusUpdateItem and places it into the status updates buffer; called by updateStatus().
 * Arguments:
 * p - process record;
 * jobN - job number.
 * 
 * The update item is created mainly based on the information currently contained in the p.
 */
void pushStatusBuffer(processRecord* p, unsigned int jobN) {
    // Allocate memory for the new status update item...
    statusUpdateItem* newI = (statusUpdateItem*) malloc(sizeof(statusUpdateItem));
    if (!newI) {
        fprintf(stderr, "FATAL ERROR (MEMORY): Allocation failed. Terminating...\n");
        exit(2);
    }

    // Next, fill the status update item with the relevant information...
    newI->proc = p;
    newI->jobNum = jobN;
    newI->exitCode = p->exitCode;
    newI->backgr = p->background;
    newI->s = p->status;
    newI->next = NULL;

    // Finally, place the status update item into the buffer.
    if (statusBuffer == NULL) { // If the queue is empty, the current item will be the first one...
        statusBuffer = newI;
    }
    else {
        statusBufferTail->next = newI;  // ...otherwise, it will be the next after the tail
    }

    statusBufferTail = newI;    // The tail should always contain the pointer to the last record
}

/*
 * updateStatus() - detects any changes in the execution status of the children and updates the job table correspondingly.
 * Also, implements a busy wait in a case a process is running in the foreground.
 * Called in several places of this code in cases when the children need to be watched and/or all the
 * recent changes in the children's statuses need to be detected and/or we need to wait until a foreground process stops/terminates.
 */
void updateStatus() {
    int status; // auxiliary variable used for storing the process' exit code as detected by waitpid()
    pid_t proc = waitpid(WAIT_ANY, &status, WNOHANG | WUNTRACED);   // See if any child processes have stopped/terminated recently

    while (1) {
        while (proc != 0) { // The loop breaks when there are processes to wait for, but none of them has stopped/terminated
            if (proc < 0) { // Some error has occurred...
                if (errno == ECHILD) break; // Not a real error; we just don't have any processes to wait for; in this case, updateStatus() will just return
                // Otherwise, we don't know what happened, but it was something bad
                fprintf(stderr, "\nFATAL ERROR (UNKNOWN): waitpid() system call failed. Terminating...\n");
                exit(3);
            }

            // Here, we need to derive the job number and the pointer to the process record of the processed process (we know only PID)
            processRecord* i = procs;   // Pointer to the process record; we initialize it with the first record in the table
            unsigned int jobNum = 1;    // job number; we initialize it with the job number of the first job in the table
            while (i != NULL && i->pid != proc) {   // If the PID in the current record is the same as the PID of the processed process,
                                                    // we have found the appropriate process record; if the pointer to the current process record is NULL,
                                                    // we have scanned the entire job table, and we couldn't find the relevant record
                jobNum++;   // increase the job number counter
                i = i->next;    // advance to the next record
            }
            if (i == NULL) {    // we haven't found the process in our job table
                fprintf(stderr, "\nFATAL ERROR (UNKNOWN): waitpid() system call failed: returned PID is not a child. Terminating...\n");
                exit(3);
            }
            i->exitCode = status;   // update the exit code in the record
            // Update the execution status in the record
            if (WIFEXITED(status)) i->status = done;
            else if (WIFSIGNALED(status)) i->status = terminated;
            else if (WCOREDUMP(status)) i->status = terminated;
            else if (WIFSTOPPED(status)) i->status = stopped;

            pushStatusBuffer(i, jobNum);    // Place in the queue for printing the update message

            // If the process was in the foreground, and now it is not running, we need to set the currentProc pointer to NULL
            if (!i->background) {
                if (currentProc != i) {
                    fprintf(stderr, "\nFATAL ERROR (UNKNOWN): job table is corrupt\n");
                    exit(4);
                }
                else if (i->status != running) {
                    currentProc = NULL;
                }
            }

            // Check the next process
            proc = waitpid(WAIT_ANY, &status, WNOHANG | WUNTRACED);
        }

        // No more processes left to process

        // If no process is in the foreground, just return...
        if (currentProc == NULL) break;
        // ...otherwise, busy wait
        proc = waitpid(WAIT_ANY, &status, WUNTRACED);
    }
}

/*
 * newProcess() - creates a new process, places its record in the job table and launches it
 * 
 * Arguments:
 * command - path to the executable
 * args (array of strings) - command line arguments to be passed
 * background - background flag; non-zero if the process is to be executed in the background
 */
void newProcess(char* command, char** args, int background) {
    // Temporarily ignore all the incoming signals
    signal(SIGINT, SIG_IGN);
    signal(SIGQUIT, SIG_IGN);
    signal(SIGTSTP, SIG_IGN);
    signal(SIGTTIN, SIG_IGN);
    signal(SIGTTOU, SIG_IGN);

    // Allocate memory for the process record
    processRecord* newP = (processRecord*) malloc(sizeof(processRecord));
    if (!newP) {
        fprintf(stderr, "FATAL ERROR (MEMORY): Allocation failed. Terminating...\n");
        exit(2);
    }

    // Allocate memory for the copy of the path to executable that will be stored in the process record
    newP->command = (char*) malloc(strlen(command) + 1);
    if (!newP->command) {
        fprintf(stderr, "FATAL ERROR (MEMORY): Allocation failed. Terminating...\n");
        exit(2);
    }

    // Populate the process record with all the relevant data
    strcpy(newP->command, command);
    newP->exitCode = 0;
    newP->status = running;
    newP->background = background;

    // By default, we think that the job table is empty, so the 'prev' should point to the last record, i.e. to itself
    newP->prev = newP;
    // This record will be the last, so its 'next' will point to NULL
    newP->next = NULL;

    if (procs != NULL) {    // If the job table is not empty
        newP->prev = procs->prev;   // Update the 'prev' of the new record
        procs->prev->next = newP;   // Update the 'next' of currently the last record
        procs->prev = newP; // Update the 'prev' of the head, i.e. place the new record as the tail
    }
    else {
        procs = newP;   // The new record is the first and only record in the job table
    }

    int jobNum = nextJobNum;    // The job number of the current record is size(job table) + 1
    nextJobNum++;   // Increment the size of the job table

    pid_t childPid = fork();

    if (childPid < 0) { // An error occured
        if (errno == EAGAIN) fprintf(stderr, "Couldn't create the process: process limit exceeded.\n");
        else if (errno == ENOMEM) fprintf(stderr, "Not enough memory to create the process.\n");
        else {
            fprintf(stderr, "\nFATAL ERROR (UNKNOWN): fork() system call failed. Terminating...\n");
            exit(3);
        }
    }
    else if (childPid == 0) {   // We're in the child process now
        // Stop ignoring signals
        signal(SIGINT, SIG_DFL);
        signal(SIGQUIT, SIG_DFL);
        signal(SIGTSTP, SIG_DFL);
        signal(SIGTTIN, SIG_DFL);
        signal(SIGTTOU, SIG_DFL);

        char* semname = (char*) malloc(33); // Name of the semaphore. It should be of the form '/seashell10_childPID'
        if (!semname) {
            fprintf(stderr, "FATAL ERROR (MEMORY): Allocation failed. Terminating...\n");
            exit(2);
        }

        if (sprintf(semname, "/seashell10_%d", getpid()) < 0) {
            fprintf(stderr, "FATAL ERROR (UNKNOWN): Unable to create the name for the semaphore (child). Terminating...\n");
            exit(3);
        }

        // Open the semaphore
        if ((mainBusy = sem_open(semname, O_CREAT, S_IRWXU, 0)) == SEM_FAILED) {
            fprintf(stderr, "\nFATAL ERROR (UNKNOWN): unable to initiate a semaphore (child). Terminating...\n");
            exit(3);
        }

        sem_wait(mainBusy); // Wait until the parent does all the preliminary tasks...

        if (sem_close(mainBusy) != 0) { // ...then close the semaphore...
            fprintf(stderr, "\nFATAL ERROR (UNKNOWN): unable to close the semaphore (child). Terminating...\n");
            exit(3);
        }
        free(semname);

        // ...and execute the command.
        execv(command, args);
        _exit(-1);  // If execv() failed, exit immediately
    }
    else if (childPid > 0) {    // We're in the parent process
        char* semname = (char*) malloc(33); // Name of the semaphore. It should be of the form '/seashell10_childPID'
        if (!semname) {
            fprintf(stderr, "FATAL ERROR (MEMORY): Allocation failed. Terminating...\n");
            exit(2);
        }

        if (sprintf(semname, "/seashell10_%d", childPid) < 0) {
            fprintf(stderr, "FATAL ERROR (UNKNOWN): Unable to create the name for the semaphore (parent). Terminating...\n");
            exit(3);
        }

        // Open the semaphore
        if ((mainBusy = sem_open(semname, O_CREAT, S_IRWXU, 0)) == SEM_FAILED) {
            fprintf(stderr, "\nFATAL ERROR (UNKNOWN): unable to initiate a semaphore (parent). Terminating...\n");
            exit(3);
        }

        newP->pid = childPid;   // Update the PID stored in the record
        _printProcInfo(newP, jobNum, background, running, 0);   // Print the status update: the process is running

        if (setpgid (childPid, childPid) < 0) { // Place the child process in its own process group
            fprintf(stderr, "\nFATAL ERROR (UNKNOWN): unable to set the PGID for the child. Terminating...\n");
            exit(3);
        }

        if (!background) {  // If the process is to be executed in the foreground...
            if (tcsetpgrp(STDIN_FILENO, childPid) < 0) {    // ...hand the control over the terminal to the child process
                fprintf(stderr, "\nFATAL ERROR (UNKNOWN): unable to set the terminal foreground PGID. Terminating...\n");
                exit(3);
            }
        }

        sem_post(mainBusy); // Let the child process know that it may execute the command

        if (sem_close(mainBusy) != 0) { // Close the semaphore
            fprintf(stderr, "\nFATAL ERROR (UNKNOWN): unable to close the semaphore (parent). Terminating...\n");
            exit(3);
        }
        free(semname);

        if (!background) {  // If the process is to be executed in the foreground...
            currentProc = newP; // Update currentProc correspondingly
            updateStatus(); // busy wait
            // After the process stopped/terminated, we need to return the control over the terminal to the shell
            if (tcsetpgrp(STDIN_FILENO, getpid()) < 0) {
                fprintf(stderr, "\nFATAL ERROR (UNKNOWN): unable to set the terminal foreground PGID. Terminating...\n");
                exit(3);
            }
        }
    }

    // Stop ignoring signals
    signal(SIGINT, SIG_DFL);
    signal(SIGQUIT, SIG_DFL);
    signal(SIGTSTP, SIG_DFL);
    signal(SIGTTIN, SIG_DFL);
    signal(SIGTTOU, SIG_DFL);
}

/*
 * resumeProcess() - resumes a stopped process in the background/foreground, or brings a
 * currently running background process to the foreground
 * Called by the 'bg' and 'fg' built-in commands.
 * 
 * Arguments:
 * jN - job number of the targeted process;
 * backgr - background flag.
 */
void resumeProcess(unsigned int jN, int backgr) {
    // Temporarily ignore signals
    signal(SIGINT, SIG_IGN);
    signal(SIGQUIT, SIG_IGN);
    signal(SIGTSTP, SIG_IGN);
    signal(SIGTTIN, SIG_IGN);
    signal(SIGTTOU, SIG_IGN);

    // Find the relevant job record
    processRecord* p = procs;
    unsigned int i;
    for (i = 1; i < jN; i++) p = p->next;

    if (p->background == backgr && p->status == running) {
        printf("Nothing to do.\n");
        return;
    }
    
    if (p->status == running) printf("Attempt to bring to ");
    else printf("Attempt to resume in ");

    if (backgr) printf("background: ");
    else printf("foreground: ");

    p->background = backgr;

    _printProcInfo(p, jN, backgr, running, 0);

    if (p->status != running)   // If the process is stopped, we need to resume it by sending SIGCONT to it
        if (kill(p->pid, SIGCONT) != 0) {
            fprintf(stderr, "Unable to resume process: kill() system call failed.\n");
            return;
        }

    if (!backgr) {  // If the process is to be executed in the foreground...
        if (tcsetpgrp(STDIN_FILENO, p->pid) < 0) {  // Hand the control over the terminal to the process
            fprintf(stderr, "\nFATAL ERROR (UNKNOWN): unable to set the terminal foreground PGID. Terminating...\n");
            exit(3);
        }
        currentProc = p;    // Update currentProc
        updateStatus(); // busy wait
        if (tcsetpgrp(STDIN_FILENO, getpid()) < 0) {    // Return the control over the terminal to the shell
            fprintf(stderr, "\nFATAL ERROR (UNKNOWN): unable to set the terminal foreground PGID. Terminating...\n");
            exit(3);
        }
    }

    // Stop ignoring signals
    signal(SIGINT, SIG_DFL);
    signal(SIGQUIT, SIG_DFL);
    signal(SIGTSTP, SIG_DFL);
    signal(SIGTTIN, SIG_DFL);
    signal(SIGTTOU, SIG_DFL);
}

// getdir() - returns the string containing the current working directory
char* getdir() {
    unsigned long size = 0; // Current size of the buffer
    char* status;   // Status of the execution of getcwd()
    char* buffer = NULL;

    do {
        size += 256;    // Increase the size of the buffer
        buffer = (char*) malloc(size);  // Allocate memory for the buffer
        if (!buffer) {
           fprintf(stderr, "FATAL ERROR (MEMORY): Allocation failed. Terminating...\n");
           exit(2);
        }

        status = getcwd(buffer, size);  // Try to get the working directory by calling getcwd()
        if (status < 0 && errno != ERANGE) {    // Something unexpected & bad happened
            free(buffer);
            fprintf(stderr, "FATAL ERROR (UNKNOWN): getcwd() system call failed. Terminating...\n");
            exit(3);
            return NULL;
        }

        if (status >= 0) break; // Hurray, we obtained the working directory successfully

        free(buffer);
    } while (1);    // If we got an error (status < 0), and it is ERANGE, it just means that the size of the buffer wasn't enough,
                    // so we can increase it and try again
    return buffer;
}

/*
 * strsplit() - splits the string str into parts, using the chars in the delims string as delimiters
 * Different parts of the string are considered to be separated by characters contained in delims, in any numbers or order.
 * Any part of the string enclosed in double quotes ("some part") will never be separated, even if it contains delimiters. In such
 * case, the double quotes will be removed from the result.
 * All the characters, including delimiters and double quotes, can be escaped using '\'. In this case, they will be treated "as is", i.e.
 * a delimiter character will not separate different parts of a string, and a double quote will not be seen as a double quote.
 * A '\' can also be escaped (i.e. '\\' is '\').
 * 
 * The last item in the resulting array will always be the NULL pointer
 */
char** strsplit(char* str, const char* delims) {
    if (strpbrk(delims, "\"\\") != NULL) {  // Double quotes and the backslash cannot be delimiters
       fprintf(stderr, "FATAL ERROR [strsplit()]: An illegal character used as a delimiter. You cannot use \" and \\ as delimiters. Terminating...\n");
       exit(5);
    }

    unsigned int bufsize = 16, pos = 0; // bufsize - size of the array of strings to be returned, pos - current position in this array of strings
    char** parts = (char**) malloc(bufsize * sizeof(char*));    // Allocate memory for the array of strings,
                                                                // i.e. array of pointers to char. To make the program more efficient,
                                                                // we will not copy each part of the initial string into the new memory block,
                                                                // but instead we will just alter the str string itself, insert '\0' chars where necessary,
                                                                // and fill the 'parts' array with pointers to relevant chars in the middle of 'str'
    char* temp; // Auxiliary variable to store the string to be added to 'parts'
    char* curchar = str;    // Currently processed character
    unsigned int shift; // We will need this when we delete some characters (e.g. '\' and '"') from the initial string
    int doublequotes = 0;   // it is non-zero if double quotes were opened but not closed yet

    if (!parts) {
       fprintf(stderr, "FATAL ERROR (MEMORY): Allocation failed. Terminating...\n");
       exit(2);
    }

	while (*curchar != '\0') {  // Until we reach the end of the initial string
		curchar += strspn(curchar, delims); // Skip all the delimiters in the beginning of the new section of the string
        temp = curchar; // The new part starts here
        shift = 0;  // Set shift to 0
        if (*curchar == '\0') break;    // We may have reached the end of the initial string; in this case, we're done

        while (*curchar != '\0') {  // Break if we have reached the end of the initial string
            // If the current character is...
            if (*curchar == '\\') { // If the current character is an escape character, i.e. the backslash...
                curchar++;  // 1) go to the next character
                shift++;    // 2) increase the shift (since we're deleting the backslash)
                *(curchar - shift) = *curchar;  // 3) just copy the character after the backslash without processing it normally
                if (*curchar != '\0') curchar++;    // 4) go to the next character (unless we're at the end of the initial string)
            }
            else if ((strchr(delims, *curchar) != NULL) && !doublequotes) { // If the current character is a delimiter AND the double quotes have not been opened...
                break;  // the end of the section reached, save this section to 'parts' and start a new one
            }
            else if (*curchar == '"') { // If the current character is a double quote...
                doublequotes = !doublequotes;   // 1) switch the 'doublequotes' flag
                curchar++;  // 2) advance to the next character
                shift++;    // 3) increase the shift since we deleted the double quote
            }
            else {  // For any other character:
                *(curchar - shift) = *curchar;  // 1) copy the character to its new position
                curchar++;  // 2) go to the next character
            }
        }

        // In any case, we need to mark the end of the current section with a '\0', but then, unless we're at the end of the
        // initial string, we need to advance the curchar
        if (*curchar != '\0') {
            *(curchar - shift) = '\0';
            curchar++;
        }
        else *(curchar - shift) = '\0';

        parts[pos] = temp;  // save the current section
        pos++;

        if (pos >= bufsize) {   // If the current size of the 'parts' array is exceeded, we will need to increase it
			bufsize += 16;
			parts = (char**) realloc(parts, bufsize * sizeof(char*));
			if (!parts) {
				fprintf(stderr, "FATAL ERROR (MEMORY): Allocation failed. Terminating...\n");
				exit(2);
			}
		}
	}

	parts[pos] = NULL;  // The last item of the array should be the NULL pointer
	return parts;
}

int main(int argc, char** argv) {
    char* prompt;   // command prompt; basically, the current working directory
    char* inputstr; // the raw string that we input as the command line
    char* pathvar;  // the string to store the content of the PATH environment variable
    char* command;  // the path to the executable to be run
    char** paths;   // components of the PATH environment variable
    char** searchpaths; // array of locations where the executable is to be searched for
    char** args;    // parsed command line arguments to be passed to the command
    unsigned int i; // integer counter; to be used in several places for different reasons
    processRecord* p;   // to be used in the 'jobs' built-in command
    size_t zero = 0;    // this is to be passed to getline()
    ssize_t linelength; // the return value of getline() will be stored here
    int bckgr;  // the background flag, as determined from the command line (by the presence of the '&' suffix)

    if (setpgid (getpid(), getpid()) < 0) { // Put the shell into its own process group
        fprintf(stderr, "\nFATAL ERROR (UNKNOWN): unable to set the PGID for the main process. Terminating...\n");
        exit(3);
    }

    printAbout();   // Print the About message

    while (1) {
        updateStatus(); // See if any processes stopped/terminated and we don't know about it
        flushStatusBuffer();    // Print all the execution status update messages accumulated since the command prompt was displayed the last time

        // Display the command prompt
        prompt = getdir();
        printf("%s> ", prompt);

        // Read the command line
        zero = 0;
        inputstr = NULL;
        linelength = getline(&inputstr, &zero, stdin);

        // Was getline() call successful?
        if (linelength < 0) {
            if (feof(stdin)) {
                break;  // The user pressed Ctrl-D
            }
            else {  // Something unexpected and bad happened
                fprintf(stderr, "FATAL ERROR (I/O): Unable to read the command. Terminating...\n");
                exit(1);
            }
        }

        // Parse the command line: generate the command line arguments array
		args = strsplit(inputstr, " \t\v\r\n\a");

        // Determine whether the command line had the '&' suffix; if there was
        // such suffix, set the background flag to 1 and delete this suffix from the resulting array
        i = 0;
        while (args[i] != NULL) i++;
        if (i > 0) {
            i--;
            if (strlen(args[i]) > 0 && (args[i][strlen(args[i]) - 1] == '&')) {
                bckgr = 1;
                if (strlen(args[i]) < 2) {
                    args[i] = NULL;
                }
                else {
                    args[i][strlen(args[i]) - 1] = '\0';
                }
            }
            else {
                bckgr = 0;
            }
        }

        // If the command line was essentially empty, jump to the next command line prompt
        if (args[0] == NULL || strlen(args[0]) < 1) {
            free(inputstr);
            free(args);
            free(prompt);
            continue;
        }

        // Process built-in commands...
        if (strcmp(args[0], "help") == 0) { // 'help' built-in command
            fprintf(stderr, "help is a built-in command\n");

            printHelp();   // Print the Help message 
        }
        else if (strcmp(args[0], "cd") == 0) { // 'cd' built-in command
            fprintf(stderr, "cd is a built-in command\n");

            if (args[1] == NULL || strlen(args[1]) < 1) printf("cd: please specify a proper directory.\n"); // we need the first argument to be present and not empty
            else {
                printf("Switching to [%s]...\n", args[1]);
                if (chdir(args[1]) != 0) {  // try to switch the working directory to the one passed as the first argument
                    // Apparently, we have some error
                    if (errno == EACCES) printf("cd: access denied.\n");
                    else if (errno == ENOENT) printf("cd: directory not found.\n");
                    else if (errno == ENOTDIR) printf("cd: the specified path is not a directory.\n");
                    else if (errno == ENAMETOOLONG) printf("cd: the path is too long.\n");
                    else {  // Unexpected error
                        fprintf(stderr, "\nFATAL ERROR (UNKNOWN): chdir() system call failed. Terminating...\n");
                        exit(3);
                    }
                }
            }
        }
        else if (strcmp(args[0], "exit") == 0) { // 'exit' built-in command
            fprintf(stderr, "exit is a built-in command\n");

            free(inputstr);
            free(args);
            free(prompt);
            break;  // Exit the shell
        }
        else if (strcmp(args[0], "jobs") == 0) { // 'jobs' built-in command
            fprintf(stderr, "jobs is a built-in command\n");

            printf("%d jobs in total.\n\n", nextJobNum - 1);
            p = procs;
            // Go through the whole job table printing information about each and every process there
            for (i = 1; p != NULL; i++) {
                _printProcInfo(p, i, p->background, p->status, p->exitCode);
                p = p->next;
            }
        }
        else if (strcmp(args[0], "fg") == 0) { // 'fg' built-in command
            fprintf(stderr, "fg is a built-in command\n");

            // 1) Make sure we have the 1st argument not empty
            if (args[1] == NULL || strlen(args[1]) < 1) printf("fg: please specify a proper job number.\n");
            else {
                char* firstNonNumber = args[1];
                unsigned int jN = strtoul(args[1], &firstNonNumber, 0);
                // 2) Make sure that the first argument is a positive integer in the valid range
                if (jN < 1 || jN >= nextJobNum || *firstNonNumber != '\0') printf("fg: please specify a proper job number.\n");
                else {
                    // 3) Call resumeProcess() with background flag set to 0
                    resumeProcess(jN, 0);
                }
            }
        }
        else if (strcmp(args[0], "bg") == 0) { // 'bg' built-in command
            fprintf(stderr, "bg is a built-in command\n");

            // 1) Make sure we have the 1st argument not empty
            if (args[1] == NULL || strlen(args[1]) < 1) printf("bg: please specify a proper job number.\n");
            else {
                char* firstNonNumber = args[1];
                unsigned int jN = strtoul(args[1], &firstNonNumber, 0);
                // 2) Make sure that the first argument is a positive integer in the valid range
                if (jN < 1 || jN >= nextJobNum || *firstNonNumber != '\0') printf("bg: please specify a proper job number.\n");
                else {
                    // 3) Call resumeProcess() with background flag set to 1
                    resumeProcess(jN, 1);
                }
            }
        }
        else {  // Process external commands
            // If args[0] does not contain '/', we will look for the file named (args[0]) in the directories contained in the PATH environment variable
            // Otherwise, we'll try to locate the executable exactly where args[0] points to
            if (strchr(args[0], '/') == NULL) {
                pathvar = (char*) malloc(strlen(getenv("PATH")) + 1);

                if (!pathvar) {
                    fprintf(stderr, "FATAL ERROR (MEMORY): Allocation failed. Terminating...\n");
                    exit(2);
                }

                strcpy(pathvar, getenv("PATH"));    // Copy the content of the PATH variable
                paths = strsplit(pathvar, ":"); // Split the PATH variable into the array of strings; each of those strings is a path to a directory

                i = 0;
                while (paths[i] != NULL) i++;
                // Here, i contains the number of different paths in the PATH variable

                searchpaths = (char**) malloc((i + 1) * sizeof(char*)); // i paths + 1 NULL pointer

                if (!searchpaths) {
                    fprintf(stderr, "FATAL ERROR (MEMORY): Allocation failed. Terminating...\n");
                    exit(2);
                }

                i = 0;
                while (paths[i] != NULL) {  // Go through the whole 'paths' array
                    // Each string in the 'searchpaths' will contain the respective path from 'paths' + '/' + args[0] + '\0'
                    searchpaths[i] = (char*) malloc(strlen(paths[i]) + 2 + strlen(args[0]));
                    if (!(searchpaths[i])) {
                        fprintf(stderr, "FATAL ERROR (MEMORY): Allocation failed. Terminating...\n");
                        exit(2);
                    }

                    strcpy(searchpaths[i], paths[i]);
                    strcat(searchpaths[i], "/");
                    strcat(searchpaths[i], args[0]);
                    i++;
                }
                searchpaths[i] = NULL;  // 'searchpaths' should end with the NULL pointer

                free(pathvar);
                free(paths);
            }
            else {  // The case when args[0] contains a '/'
                // 'searchpaths' array will contain a copy of args[0] and a NULL pointer
                searchpaths = (char**) malloc(2 * sizeof(char*));

                if (!searchpaths) {
                    fprintf(stderr, "FATAL ERROR (MEMORY): Allocation failed. Terminating...\n");
                    exit(2);
                }

                searchpaths[0] = (char*) malloc(strlen(args[0]) + 1);
                if (!searchpaths[0]) {
                    fprintf(stderr, "FATAL ERROR (MEMORY): Allocation failed. Terminating...\n");
                    exit(2);
                }

                strcpy(searchpaths[0], args[0]);
                searchpaths[1] = NULL;
            }

            // By default, we suppose that the executable was not found; we signify this by assigning the NULL pointer to 'command'
            command = NULL;
            i = 0;
            while (searchpaths[i] != NULL) {
                fprintf(stderr, "File [%s]: ", searchpaths[i]);
                // Does the file at searchpaths[i] exist and do we have access to it?
                if (access(searchpaths[i], F_OK) != 0) {
                    if (errno == EACCES) fprintf(stderr, "access denied.\n");
                    else if (errno == ELOOP) fprintf(stderr, "too many symbolic links.\n");
                    else if (errno == ENAMETOOLONG) fprintf(stderr, "the path is too long.\n");
                    else if (errno == ENOENT) fprintf(stderr, "not found.\n");
                    else if (errno == ENOTDIR) fprintf(stderr, "wrong path.\n");
                    else {  // Unexpected error
                        fprintf(stderr, "\nFATAL ERROR (UNKNOWN): access() system call failed. Terminating...\n");
                        exit(3);
                    }
                    i++;
                    continue;   // Go to the next path in 'searchpaths' (if such exists)
                } else {    // The file at searchpaths[i] exists
                    fprintf(stderr, "exists; ");
                    if (access(searchpaths[i], X_OK) != 0) {    // Do we have the permission to execute the file at searchpaths[i]?
                        if (errno == EFAULT || errno == EINVAL || errno == EIO || errno == ENOMEM || errno == ETXTBSY) {
                            fprintf(stderr, "\nFATAL ERROR (UNKNOWN): access() system call failed. Terminating...\n");
                            exit(3);
                        } else {
                            fprintf(stderr, "cannot be executed.\n");
                            i++;
                            continue;   // Go to the next path in 'searchpaths' (if such exists)
                        }
                    } else {
                        // We can execute the file at searchpaths[i], so we update 'command' accordingly
                        fprintf(stderr, "executable.\n");
                        command = searchpaths[i];
                        break;
                    }
                }
                i++;
            }

            if (command == NULL) {  // We were unable to find the executable
                printf("[%s]: not a command\n", args[0]);
            } else {    // We found the executable, and the path to it is stored in 'command'
                fprintf(stderr, "Executing [%s]...\n", command);

                // Executing the command
                newProcess(command, args, bckgr);
            }

            // Freeing all the allocated resources
            i = 0;
            while (searchpaths[i] != NULL) {
                free(searchpaths[i]);
                i++;
            }
            free(searchpaths);
        }

        // Freeing all the allocated resources
        free(inputstr);
        free(args);
        free(prompt);
    }   // Next command prompt

    updateStatus(); // Just before we exit the shell, let us take the status updates from all the processes that stopped/terminated so far,
                    // so that we avoid having zombies. Unfortunately, we may have some orphans when we exit the shell:
                    // if the user exits the shell with the 'exit' command, we could ask them what they want to do with the unfinished processes;
                    // however, if the user pressed Ctrl-D, the terminal will not allow us to take any more input from the user, so we'll need to decide
                    // what to do with the children ourselves. This problem could be handled by operating the terminal in the raw mode,
                    // but it would take much more effort to implement. Also, we could just send SIGKILL to all the children, but,
                    // in my opinion, this solution is not good enough.
    flushStatusBuffer();    // Print all the status update messages that have accumulated so far

    printf("\nBye.\n");
    return 0;
}
